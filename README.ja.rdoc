= Striuct

* http://github.com/kachick/striuct
* https://rubygems.org/gems/striuct
* http://rubyforge.org/projects/striuct

== DESCRIPTION

Strict Struct の略です。そのまま StrictStruct でも使えます。

メソッド呼び出しが効いてメンバ名チェックのかかるStructは、Hashより気持ち良く感じます。
でもStructを使う場面って、参照先にもチェックをかけたいと思う事が多くありませんか？

RubyのStructを愛用しているんだけど、こういった部分をなんとかしたいと感じている方へお勧めします。

1. ノーガードで参照の付けはずしが出来るのはおっかない
2. かといって、型チェックしか出来ないようじゃ動的言語のメリットが死ぬんではなかろうか
3. どうせなら、チェックだけじゃなくキャストなりもやらせた上で格納したいときってあるよね
4. このメンバの標準値は明らかにnilじゃない
5. Structは好きだけど、この辺クリアしようとしたら上書きばかりすることになって使いづらい
z. 毎回毎回同じような構造体クラス書くのは面倒だ

== FEATURES

* メンバ毎に、参照条件を簡単に定義できます。
* 型チェックではなく式チェックなので、動的言語の良さを殺しません
* Proc(lambda)やMethod等 を使うことで、さらに柔軟なチェックが可能です
* 参照前に、ちょっとした処理を加える事も可能です
* Structの心地よい操作感を残したまま機能追加をしています。
* 既存クラスやメソッドの上書き等はしない、控えめな名前空間
* pure-ruby

== PLAN

* https://github.com/kachick/striuct/wiki/Plan

== SYNOPSIS

* setup
    require 'striuct'

* Structには無い機能として、memberというクラスマクロを用意しました。
  ここでの定義順通りにindexが振られます。
  引数1にメンバ名、引数2以降に参照条件を渡して下さい。caseのwhen節と同じ感覚で使えます。
  引数1のみの場合、Structのメンバと同様ノーチェックになります。
    class User < Striuct.new
      member :id, Integer
      member :address, /\A((\w+) ?)+\z/
      member :age, (20..140)
      member :name, /\A\w+\z/, /\A\w+ \w+\z/
    end

    # これはOK
    user = User.new 128381, 'Tokyo Japan', 20

    # これもOK
    user.age = 30
    user.name = 'taro yamada'

    # これは駄目(例外 Striuct::ConditionError)
    user[:id] = 10.0
    user[1] = 'Tokyo-to'
    user.age = 19
    user.name = nil

* 単純な例としてはこんな感じですが、更に細かいチェッカが必要であれば関数的オブジェクトを使って下さい。
  この時Proc(lambda)を自身のコンテキストで評価する為、Methodより使うシーンが多いと思います。
    class Game < Striuct.new
      member :monsters, ->monsters{[monsters - characters].empty?}
      member :characters, Array
    end
 
* リンク貼る時どれだけ注意しても、その後参照先のオブジェクトがぶっ壊れる可能性は残りますよね。
  これは致し方無いと思うので、チェックだけでも簡単にできるようにしています。
    user.strict? #=> true
    user.address.clear
    user.strict? #=> false

* 更に細かい用途ですが、memberマクロへブロックを渡しておくと、チェック後一処理を加えた値を参照するように出来ます。
    class User2 < Striuct.new
      # 数字っぽければIntegerへ変換してから
      member :age, /\A\d+\z/, Numeric do |v|
        Integer v
      end
      
      # Stringっぽさが強い時だけ、Symbolに変換。
      member :name, ->v{v.respond_to? :to_str} do |v|
        v.to_str.to_sym
      end
    end
    
    user2 = User2.new
    user2.age = 9 #=> 9(Fixnum)
    user2.age = 10.1 #=> 10(Fixnum)
    user2.age = '10' #=> 10(Fixnum)

* Structだと標準値は全て nil になってしまいますが、これもクラスマクロで定義できるようにしました。
    class User3 < Striuct.new
      member  :lank, Fixnum
      default :lank, 3
      member  :name
    end
    
    user3 = User3.new
    user3.lank #=> 3
    
* 「意図的にnilを定義する」事もありますよね
  初期nilとの判別用メソッドを追加しました。
   
   user3.name  #=> nil
   user3.assign? :name #=> false
   user3.name = nil
   user3.assign? :name #=> true

* Structの良さは無くしたくないですよね
    Sth1 = Striuct.new :id, :last_name, :family_name, :address, :age

    Sth2 = Striuct.new do
      def m
      end
    end  

*  混在利用させたい向きとかに、Structにも同じようなインターフェイスを用意できます。
  逆に言うと、これを使わない限りは名前空間をあんまし汚しません。
    require 'striuct/import'

* 他にも幾つか機能追加しています。

* このあともうちょっと増える予定です。

* 早わかり
  https://github.com/kachick/striuct/wiki/EasyGuide

== REQUIREMENTS

=== Ruby
* 1.9.3
* 1.9.2

== INSTALL

* sudo gem install striuct

== LICENSE

(The MIT License)

Copyright (c) 2011  Kenichi Kamiya

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.