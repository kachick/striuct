= Striuct

* http://github.com/kachick/striuct
* https://rubygems.org/gems/striuct
* http://rubyforge.org/projects/striuct

== DESCRIPTION

Structと同じぐらいの手軽さで使える、Structより堅いコンテナを目指しています。

メンバ名チェックのかかるStructは、安心感という意味ではHashよりも好ましい事があるかと思います。
でもそうやってStructを使うぐらいなわけだから、名前だけじゃなく参照先にもある程度の代入条件をかけたいと思う事が多くありませんか？

RubyのStructを愛しつつも、こういった部分をなんとかしたいと感じている方へお勧めします。

1. ノーガードで参照を付けられるのがおっかないときもある
2. かといって、型チェックしか出来ないようじゃRubyのメリットが死ぬんではなかろうか
3. メンバ名でフツーのメソッド名を上書きしかねないのもおっかない
4. 最初に代入したオブジェクトのクラスで固定したい
5. どうせなら、チェックだけじゃなくキャストなりもやらせたものを参照したい
6. メンバによっては標準値も定義したい

== FEATURES

* メンバ毎に、参照条件を簡単に定義できます。
* 型チェックではなく式チェックなので、動的言語の良さを殺しません
* Proc(lambda)やMethod等 を使うことで、さらに柔軟なチェックが可能です
* どれか一つの構造体で最初に代入したオブジェクトのクラスで固定するようなメンバを作れます。
* 参照前に、ちょっとした処理を加える事も可能です
* 構造体としてのメンバ追加時、Rubyの既存メソッドと干渉しないかを指定レベル別にチェック可能です。
* Structの心地よい操作感を残したまま機能追加をしています。
* 既存クラスやメソッドの上書き等を（勝手には）しない、控えめな名前空間
* pure-ruby

== SYNOPSIS

* setup
    require 'striuct'

* 2つの名前空間をお借りしますが、どっちも同じクラスを指します
    Striuct
    StrictStruct

=== Struct+ "Secure"

* memberというクラスマクロを使うことで構造体のメンバを定義できます。
  引数2以降に参照するための「条件」を渡して下さい。
  caseのwhen節と大体同じ感覚なので、これだけでも型チェック+で使えます。
    class User < Striuct.new
      member :id,   Integer
      member :age,  (20..140)
      member :name, /\A\w+\z/, /\A\w+ \w+\z/
    end

    # pass
    user = User.new 128381, 20

    # pass
    user.age = 30
    user[2] = 'taro yamada'

    # fail
    user[:id] = 10.0
    user.age = 19
    user[2] = nil


* 単更に柔軟なチェッカが必要であれば関数オブジェクトを使って下さい。
  この時Proc(lambda)を構造体インスタンスのコンテキストで評価する為、他のメンバと連携したチェックも簡単です。
    module Game
      class Character
      end

      class DB < Striuct.new
        member :monsters,   ->list{(list - characters).empty?}
        member :characters, ->list{list.all?{|c|c.kind_of? Character}}
      end

      monster = Character.new
      db = DB.new
      
      # fail
      db.characters = [1, 2]
      
      # pass
      db.characters = [monster, Character.new]
      
      # fail
      db.monsters = [:dummy]
      
      # pass
      db.monsters = [monster]
    end

* 構造体クラスのコンテキスト内だけで使える "inference" というメソッドの返り値を渡すと、
  最初に参照したオブジェクトのクラスが、以降全インスタンスでの参照条件となります。
    class FlexibleContainer < Striuct.new
      member :anything, inference
      member :number,   inference, Numeric
    end

    fc1, fc2 = FlexibleContainer.new, FlexibleContainer.new
    # pass
    fc1.anything = 'str'
 
    # fail
    fc1.anything = :sym
    fc2.anything = :sym
    
    # pass
    fc2.anything = 'string too'
    
    # fail
    fc1.number = 'str'
    
    # pass
    fc1.number = 1.0

    # fail
    fc2.number = 1

* Structはこんな感じで、ノーガード上書き＆メソッド定義出来ない物も無警告で進みます
    NoGuard = Struct.new :__send__, :'?  !'
    noguard = NoGuard.new false
    p noguard.__send__
    p noguard.methods.include?(:'?  !') # lost!!

* ということで、意図しない上書き等を防ぐために安全度を設定出来るようにしました。
  標準値は上から2番目です。
    class SafetyNaming < Striuct.new
      begin
        member :__send__
      rescue
        p $!
      end
      
      begin
        member :'?  !'
      rescue
        p $!
      end
      
      # ここで下げると、定義可能に
      protect_level :struct
      
      member :__send__, :'?  !'
    end

* この辺をチェックするためのメソッドも用意してあります。
  * acccept? / sufficient?
  * restrict?
  * strict?
  * secure?
  * cname?

=== Struct+ "Handy"

* memberマクロへブロックを渡しておくと、チェック後一処理加えた値を代入可能です。
    class User2 < Striuct.new
      # 数字っぽければIntegerへ変換してから
      member :age, /\A\d+\z/, Numeric do |v|
        Integer v
      end
      
      # Symbolに変換した上で代入。
      member :name, ->v{v.respond_to? :to_s} do |v|
        v.to_s.to_sym
      end
    end
    
    user2 = User2.new
    user2.age = 9 #=> 9(Fixnum)
    user2.age = 10.1 #=> 10(Fixnum)
    user2.age = '10' #=> 10(Fixnum)
    
    user2.name = 10 #=> :10(Symbol)
    user2.name = Class #=> :Class(Symbol)

* defaultマクロを用いると、メンバ毎標準値の設定が可能です
    class User3 < Striuct.new
      member  :lank, Fixnum
      default :lank, 3
      member  :name
    end
    
    user3 = User3.new
    user3.lank #=> 3

* 「意図的なnil」もあるので、初期nilとの判別用メソッドを追加しました。
   user3.name  #=> nil
   user3.assign? :name #=> false
   user3.name = nil
   user3.assign? :name #=> true

==== new constructors

* Subclass.define は、生成時から先オブジェクトを変える必要が無いケースで使います。
  * すべてのメンバに何かしら参照がないと、例外を吐きます。
  * 返り値はfrozenです(引数へ偽で変更可)
      user3 = User3.define do |r|
        r.lank = 10
        r.name = 'foo'
      end

* Subclass.load_pairs は、HashなりHashっぽいものから作る時用です。
    user3 = User3.load_pairs lank:10, name: 'foo'

=== Keeping Struct's good interface
    Sth2 = Striuct.new do
      def my_special_method
      end
    end
    
    Sth2.new.respond_to?(:my_special_method) #=> true

* 混在利用させたい向きとかに、Structにもある程度同じようなインターフェイスを用意できます。
  これを使わない限りは名前空間を汚しません。
    require 'striuct/import'

* 他にも幾つか機能追加しています。
  また、ここの例だと返り値や例外が見づらいと思うので、同梱の example.rb を動かしてみてください

* Wiki
  https://github.com/kachick/striuct/wiki

== REQUIREMENTS

=== Ruby
* 1.9.3
* 1.9.2

== INSTALL

* sudo gem install striuct

== LICENSE

(The MIT License)

Copyright (c) 2011  Kenichi Kamiya

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.