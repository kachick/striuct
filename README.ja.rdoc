= Striuct

* http://github.com/kachick/striuct
* https://rubygems.org/gems/striuct
* http://rubyforge.org/projects/striuct

== DESCRIPTION

Strict Struct の略です。そのまま StrictStruct でも使えます。

メンバ名チェックのかかるStructは、安心感という意味ではHashよりも好ましい事があるかと思います。
でもそうやってStructを使うぐらいなわけだから、名前だけじゃなく参照先にもある程度の代入条件をかけたいと思う事が多くありませんか？

RubyのStructを愛しつつも、こういった部分をなんとかしたいと感じている方へお勧めします。

1. ノーガードで参照を付けられるのがおっかないときもある
2. かといって、型チェックしか出来ないようじゃRubyのメリットが死ぬんではなかろうか
3. メンバ名でフツーのメソッド名を上書きしかねないのもおっかない
4. 最初に代入したオブジェクトのクラスで固定したい
5. どうせなら、チェックだけじゃなくキャストなりもやらせたものを参照したい
6. メンバによっては標準値も定義したい

== FEATURES

* メンバ毎に、参照条件を簡単に定義できます。
* 型チェックではなく式チェックなので、動的言語の良さを殺しません
* Proc(lambda)やMethod等 を使うことで、さらに柔軟なチェックが可能です
* どれか一つの構造体で最初に代入したオブジェクトのクラスで固定するようなメンバを作れます。
* 参照前に、ちょっとした処理を加える事も可能です
* 構造体としてのメンバ追加時、Rubyの既存メソッドと干渉しないかを指定レベル別にチェック可能です。
* Structの心地よい操作感を残したまま機能追加をしています。
* 既存クラスやメソッドの上書き等を（勝手には）しない、控えめな名前空間
* pure-ruby

== SYNOPSIS

* setup
    require 'striuct'

* Structには無い機能として、memberというクラスマクロを用意しました。
  ここでの定義順通りにindexが振られます。
  引数1にメンバ名、引数2以降に参照条件を渡して下さい。caseのwhen節と同じ感覚で使えます。
  引数1のみの場合、Structのメンバと同様ノーチェックになります。
    class User < Striuct.new
      member :id, Integer
      member :address, /\A((\w+) ?)+\z/
      member :age, (20..140)
      member :name, /\A\w+\z/, /\A\w+ \w+\z/
    end

    # これはOK
    user = User.new 128381, 'Tokyo Japan', 20

    # これもOK
    user.age = 30
    user.name = 'taro yamada'

    # これは駄目(例外 Striuct::ConditionError)
    user[:id] = 10.0
    user[1] = 'Tokyo-to'
    user.age = 19
    user.name = nil

 
* リンク貼る時どれだけ注意しても、その後参照先のオブジェクトがぶっ壊れる可能性は残りますよね。
  これは致し方無いと思うので、チェックだけでも簡単にできるようにしています。
    user.strict? #=> true
    user.address.clear
    user.strict? #=> false

* 単純な例としてはこんな感じですが、更に細かいチェッカが必要であれば関数オブジェクトを使って下さい。
  この時Proc(lambda)を構造体インスタンスのコンテキストで評価する為、他のメンバと連携したチェックも簡単です。
    module Game
      class Character
      end

      class DB < Striuct.new
        member :monsters, ->monsters{(monsters - characters).empty?}
        member :characters, ->characters{characters.all?{|c|c.kind_of? Character}}
      end
      
      monster = Character.new
      db = DB.new
      
      # fail
      db.characters = [1, 2]
      
      # pass
      db.characters = [monster, Character.new]
      
      # fail
      db.monsters = [:dummy]
      
      # pass
      db.monsters = [monster]
    end

* 構造体クラスのコンテキスト内だけで使える "inference" というメソッドの返り値を渡すと、
  最初にどれか一つのインスタンスで参照したクラスが以降の参照条件となります。
    class FlexibleContainer < Striuct.new
      member :anything, inference
      member :number, inference, Numeric
    end

    fc1, fc2 = FlexibleContainer.new, FlexibleContainer.new
    # pass
    fc1.anything = 'str'
 
    # fail
    fc1.anything = :sym
    fc2.anything = :sym
    
    # pass
    fc2.anything = 'string too'
    
    # fail
    fc1.number = 'str'
    
    # pass
    fc1.number = 1.0

    # fail
    fc2.number = 1


* memberマクロへブロックを渡しておくと、チェック後一処理加えた値を代入可能です。
    class User2 < Striuct.new
      # 数字っぽければIntegerへ変換してから
      member :age, /\A\d+\z/, Numeric do |v|
        Integer v
      end
      
      # Symbolに変換した上で代入。
      member :name, ->v{v.respond_to? :to_s} do |v|
        v.to_s.to_sym
      end
    end
    
    user2 = User2.new
    user2.age = 9 #=> 9(Fixnum)
    user2.age = 10.1 #=> 10(Fixnum)
    user2.age = '10' #=> 10(Fixnum)
    
    user2.name = 10 #=> :10(Symbol)

* Structだと標準値は全て nil になってしまいますが、これもクラスマクロで定義できるようにしました。
    class User3 < Striuct.new
      member  :lank, Fixnum
      default :lank, 3
      member  :name
    end
    
    user3 = User3.new
    user3.lank #=> 3

* 「意図的にnilを定義する」事もありますよね
  初期nilとの判別用メソッドを追加しました。
   
   user3.name  #=> nil
   user3.assign? :name #=> false
   user3.name = nil
   user3.assign? :name #=> true

* Structはこんな感じで、ノーガード上書き＆メソッド定義出来ない物も無警告で進みます
    NoGuard = Struct.new :__send__, :'?  !'
    noguard = NoGuard.new false
    p noguard.__send__
    p noguard.methods.include?(:'?  !') # lost!!

* ということで、意図しない上書き等を防ぐために安全度を設定出来るようにしました。
  標準値は上から2番目です。
    class SafetyNaming < Striuct.new
      begin
        member :__send__
      rescue
        p $!
      end
      
      begin
        member :'?  !'
      rescue
        p $!
      end
      
      # ここで下げると、定義可能に
      protect_level :struct
      
      member :__send__, :'?  !'
    end

* Structの良さは無くしたくないですよね
    Sth1 = Striuct.new :id, :last_name, :family_name, :address, :age

    Sth2 = Striuct.new do
      def my_special_method
      end
    end
    
    Sth2.new.respond_to?(:my_special_method) #=> true

* 混在利用させたい向きとかに、Structにも同じようなインターフェイスを用意できます。
  逆に言うと、これを使わない限りは名前空間をあんまし汚しません。
    require 'striuct/import'

* 他にも幾つか機能追加しています。
  また、ここの例だと返り値や例外が見づらいと思うので、同梱の example.rb を動かしてみてください

* 早わかり
  https://github.com/kachick/striuct/wiki/EasyGuide

== REQUIREMENTS

=== Ruby
* 1.9.3
* 1.9.2

== INSTALL

* sudo gem install striuct

== LICENSE

(The MIT License)

Copyright (c) 2011  Kenichi Kamiya

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.