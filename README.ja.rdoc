= Striuct

* http://github.com/kachick/striuct
* https://rubygems.org/gems/striuct
* http://rubyforge.org/projects/striuct

== DESCRIPTION

Structと同じかそれ以上の手軽さで扱える、Structより堅いコンテナを目指しています。

メンバ名にチェックがかかる＆一つの新しいクラスとして扱えるStructは、場面によってはHashよりも好ましい事があるかと思います。
でもそうやってStructを使うぐらいなわけだから、値の方にもある程度のチェックをかけたいと思う事が多くありませんか？

RubyのStructを愛しつつも、こういった部分をなんとかしたいと感じている方へお勧めします。

1. ノーガードで参照を付けられるのがおっかないときもある
2. かといって、型チェックしか出来ないようじゃRubyのメリットが死ぬんではなかろうか
3. メンバ名でフツーのメソッド名を上書きしかねないのもおっかない
4. 最初に代入したオブジェクトのクラスで固定したい（これは無いか）
5. どうせなら、チェックだけじゃなくキャストなりやらせたものを参照したい
6. メンバによっては標準値も定義したい
7. Hashとの親和性を高くしたい

== FEATURES

* メンバ毎に、参照条件を簡単に定義できます。
* 型チェックではなく式チェックなので、動的型の良さを殺しません
* Proc(lambda)やMethod等 を使うことで、さらに柔軟なチェックが可能です
* どれか一つの構造体で最初に代入したオブジェクトのクラスに沿うようなメンバを作れます。
* 参照直前に、ちょっとした処理を加える事も可能です
* 構造体としてのメンバ追加時、Rubyの既存メソッドと干渉しないかを指定レベル別にチェック出来ます。
* なるべくStructの心地よい操作感を残したまま機能追加をしています。
* 既存クラスやメソッドの上書き等を（勝手には）しない、控えめな名前空間
* Pure Ruby

== SYNOPSIS

* setup
    require 'striuct'

* 2つの名前空間をお借りしますが、どっちも同じクラスを指します
    Striuct
    StrictStruct

=== Struct+ "Safety"

==== 基本的な使い方

* memberというクラスマクロを使うことで構造体のメンバを定義できます。
  引数2以降に、参照するための「条件」を渡して下さい。
  caseのwhen節と大体同じ感覚なので、これだけでも型チェック+で使えます。
  何も条件を渡さなければ、Struct同様ノーチェックです。
    class User < Striuct.new
      member :id,   Integer
      member :age,  (20..140)
      member :name, /\A\w+\z/, /\A\w+ \w+\z/
    end

    # pass
    user = User.new 128381, 20

    # pass
    user.age = 30
    user[2] = 'taro yamada'

    # fail
    user[:id] = 10.0
    user.age = 19
    user[2] = nil


* 更に柔軟なチェッカが必要であれば関数的なオブジェクトを使って下さい。
  この時Proc(lambda)を構造体インスタンスのコンテキストで評価する為、他のメンバと連携したチェックも簡単です。
    module Game
      class Character
      end

      class DB < Striuct.new
        member :monsters,   ->list{(list - characters).empty?}
        member :characters, ->list{list.all?{|c|c.kind_of? Character}}
      end

      monster = Character.new
      db = DB.new
      
      # fail
      db.characters = [1, 2]
      
      # pass
      db.characters = [monster, Character.new]
      
      # fail
      db.monsters = [:Character.new]
      
      # pass
      db.monsters = [monster]
    end

* 構造体クラスのコンテキスト内だけで使える "inference" というメソッドの返り値を渡すと、
  最初に参照したオブジェクトのクラスが、以降全インスタンスでの参照条件となります。
    class FlexibleContainer < Striuct.new
      member :anything, inference
      member :number,   inference, Numeric
    end

    fc1, fc2 = FlexibleContainer.new, FlexibleContainer.new
    # pass
    fc1.anything = 'str'
 
    # fail
    fc1.anything = :sym
    fc2.anything = :sym
    
    # pass
    fc2.anything = 'string too'
    
    # fail
    fc1.number = 'str'
    
    # pass
    fc1.number = 1.0

    # fail
    fc2.number = 1

==== 意図しない名前干渉は避ける

* Structはこんな感じで、ノーガード上書き＆メソッド定義出来ない物も無警告で進みます(object_id, __id__ なんかもそうですね)
    NoGuard = Struct.new :__send__, :'?  !'
    noguard = NoGuard.new false
    p noguard.__send__
    p noguard.methods.include?(:'?  !') # lost!!

* ということで、意図しない上書き等を防ぐために安全度を設定出来るようにしました。
  標準値は上から2番目の「:prevent」です。
    class SafetyNaming < Striuct.new
      begin
        member :__send__
      rescue
        p $!
      end
      
      begin
        member :'?  !'
      rescue
        p $!
      end
      
      # ここで下げると、定義可能に
      protect_level :struct
      
      member :__send__, :'?  !'
    end

==== この辺に関わる述語メソッド

* acccept? / sufficient?   # そのメンバにその値が設定出来るか
* conditionable?           # 条件式として受け入れ可能なオブジェクトか
* inference?               # 定義時にinferenceを使った上で、一つも参照されていないか
* restrict?                # そのメンバに参照条件がかけられているか
* strict?                  # 今時点で全てのメンバが参照条件を満たしているか
* secure?                  # インスタンスもクラスも変動することない状態で、インスタンスにfreezeがかかっているか
* cname?                   # そのメンバ名は、今のprotect level下で望ましいものか


=== Struct+ "Handy"

==== Flavor

* memberマクロへブロックを渡しておくと、チェック後一処理加えた値を参照可能です。
    class User2 < Striuct.new
      # 数字っぽければIntegerへ変換してから
      member :age, /\A\d+\z/, Numeric do |v|
        Integer v
      end
      
      # Symbolに変換した上で代入。
      member :name, ->v{v.respond_to? :to_s} do |v|
        v.to_s.to_sym
      end
    end
    
    user2 = User2.new
    user2.age = 9 #=> 9(Fixnum)
    user2.age = 10.1 #=> 10(Fixnum)
    user2.age = '10' #=> 10(Fixnum)
    
    user2.name = 10 #=> :10(Symbol)
    user2.name = Class #=> :Class(Symbol)

==== Default

* defaultマクロを用いることで、メンバ毎に標準値を定義することが出来ます。
    class User3 < Striuct.new
      member  :lank, Fixnum
      default :lank, 3
      member  :name
    end
    
    user3 = User3.new
    user3.lank #=> 3

* 「意図的なnil」との区別を付けられます。
   user3.name  #=> nil
   user3.assign? :name #=> false
   user3.name = nil
   user3.assign? :name #=> true

==== New Constructors

* Subclass.define は、生成時から先オブジェクトを変える必要が無いケースで使います。
  * ブロックパラメータに新しいインスタンスがわたり、またこれが返り値となります
  * すべてのメンバに何かしら参照がないと、例外を吐きます。(引数へ偽で変更可)
  * 返り値は凍結した状態になります。(引数へ偽で変更可)
      user3 = User3.define do |r|
        r.lank = 10
        r.name = 'foo'
      end

* Subclass.[](load_pairs) は、HashなりHashっぽいものから作る時用です。
  # Struct.[] の仕様とは異なります。
    user3 = User3[lank:10, name: 'foo']

=== あくまでもStructっぽく

* Struct使い(?)が余り違和感を感じ無いようにしたつもりです。
    Sth2 = Striuct.new do
      def my_special_method
      end
    end
    
    Sth2.new.respond_to?(:my_special_method) #=> true

=== おまけ

* Hashへの変換も一発です。
    user3.to_h #=> {:lank=>3, :name=>nil}

* 混在利用させたい向きとかに、Structにもある程度同じようなインターフェイスを用意できます。
  逆に言うと、これを使わない限りは名前空間を汚しません。(標準では読み込みません)
    require 'striuct/import'

* Structと比較して目立つ追加・変更点は多分このぐらいです。
  ここの例だと返り値や例外が見づらいと思うので、同梱の example.rb を動かしてみてください

* tips:
  * run example.rb
  * https://github.com/kachick/striuct/wiki

== REQUIREMENTS

=== Ruby

* Ruby 1.9.2 and later (tested 1.9.2, 1.9.3)

== INSTALL

* sudo gem install striuct

== LICENSE

(The MIT License)

Copyright (c) 2011  Kenichi Kamiya

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.